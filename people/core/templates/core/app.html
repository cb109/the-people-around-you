<div id="app">
  <!-- Main fixed UI -->
  <div
    style="
      position: fixed;
      padding: 16px;
      z-index: 9999;
    "
  >
    <div>
      <button
        type="button"
        class="btn btn-lg btn-primary"
        style="margin-right: 8px"
        @click="showDialog = true"
      >
        Add Person
      </button>
      <button
        type="button"
        class="btn btn-lg btn-secondary"
        @click="stageConfig.draggable = !stageConfig.draggable"
      >
        Mode: <span v-if="stageConfig.draggable">Pan</span><span v-else>Select</span>
      </button>
    </div>
    <!-- Add-Person Dialog -->
    <div class="modal modal-sm" :class="{active: showDialog}">
      <a href="javascript:void(0)" class="modal-overlay" @click="closeDialog()"></a>
      <div class="modal-container">
        <div class="modal-header"><a class="btn btn-clear float-right" href="javascript:void(0)" @click="closeDialog()"></a>
          <div class="modal-title h5">Add Person</div>
        </div>
        <div class="modal-body">
          <div class="content">
            <form>
              <div class="form-group">
                <label class="form-label" for="first_name">First Name</label>
                <input class="form-input" id="first_name" v-model="firstName" type="text" placeholder="John">
              </div>
              <div class="form-group">
                <label class="form-label" for="last_name">Last Name</label>
                <input class="form-input" id="last_name"v-model="lastName" type="text" placeholder="Doe">
              </div>
            </form>
          </div>
        </div>
        <div class="modal-footer">
          <button
            :disabled="!dialogFormIsValid"
            class="btn btn-primary"
            @click="createPerson()"
          >
            Add
          </button>
        </div>
      </div>
    </div>
  </div>
  <!-- Konva Stage -->
  <v-stage
    ref="stage"
    :config="stageConfig"
  >
    <v-layer ref="layer">
      <template
        v-for="(person, personIndex) in persons"
        :key="'person-' + personIndex"
      >
        <v-group
          :config="{
            draggable: true,
            x: person.x,
            y: person.y,
            name: 'person-group',
          }"
          @dragend="onPersonMoved($event, person)"
          @touchend="onPersonMoved($event, person)"
        >
          <v-group
            :config="{
              clipFunc: clipFuncCircle,
            }"
          >
            <v-image
              :key="person.image"
              :config="{
                image: person.image,
                name: 'person-image',
              }"
            />
          </v-group>
          <v-group>
            <v-text
              :config="{
                x: 0,
                y: 320,
                width: 300,
                text: person.first_name + ' ' + person.last_name,
                align: 'center',
                fontSize: 36,
                name: 'person-name',
              }"
            />
          </v-group>
        </v-group>
      </template>
    </v-layer>
  </v-stage>
</div>

<script>
  // Setup person list as passed from Django initially.
  const initialPersons = [
    {% for person in initial_persons %}
      {
        id: {{ person.id }},
        first_name: "{{ person.first_name }}",
        last_name: "{{ person.last_name }}",
        x: {{ person.x }},
        y: {{ person.y }},
        avatar: "{{ person.avatar }}",
        image: null,
      },
    {% endfor %}
  ];

  function clipFuncCircle (ctx) {
    ctx.arc(150, 150, 150, 0, Math.PI * 2, false);
  }

  const app = Vue.createApp({
    delimiters: ['[[', ']]'],
    data() {
      return {
        // Konva
        clipFuncCircle: clipFuncCircle,
        stageConfig: {
          width: window.innerWidth,
          height: window.innerHeight,
          draggable: true,
        },
        // Main fixed UI
        showDialog: false,
        firstName: '',
        lastName: '',
        // Backend data
        persons: initialPersons,
      };
    },
    computed: {
      dialogFormIsValid() {
        return (
          !!this.firstName && !this.firstName.trim() == '' &&
          !!this.lastName && !this.lastName.trim() == ''
        );
      },
    },
    created() {
      this.loadPersonImages();
    },
    mounted() {
      this.setupZoom();
      this.setupSelection();
    },
    methods: {
      resetDialog() {
        this.firstName = '';
        this.lastName = '';
      },
      closeDialog() {
        this.showDialog = false;
      },
      createPerson() {
        const vm = this;
        const payload = {
          first_name: this.firstName,
          last_name: this.lastName,
        };
        httpPost('/persons/create', payload)
          .then((response) => response.json())
          .then((person) => {
            function callback(person) {
              vm.persons.push(person);
            }
            vm.loadPersonImage(person, callback);
            vm.resetDialog();
            vm.closeDialog();
          });
      },
      onPersonMoved(e, person) {
        const payload = {
          x: e.target.attrs.x,
          y: e.target.attrs.y,
        };
        httpPost('/persons/' + person.id, payload);
      },
      loadPersonImages() {
        for (let person of this.persons) {
          this.loadPersonImage(person);
        };
      },
      loadPersonImage(person, callback = null) {
        const image = new Image();
        if (!person.avatar) {
          return;
        }
        image.src = person.avatar;
        image.onload = () => {
          person.image = image;
          if (callback) {
            callback(person);
          }
          console.log('loaded img of person', person);
        };
      },
      getStage() {
        return this.$refs.stage.getStage();
      },
      setupZoom() {
        const stage = this.getStage();
        const scaleBy = 1.12;
        stage.on('wheel', (e) => {
          // stop default scrolling
          e.evt.preventDefault();

          var oldScale = stage.scaleX();
          var pointer = stage.getPointerPosition();

          var mousePointTo = {
            x: (pointer.x - stage.x()) / oldScale,
            y: (pointer.y - stage.y()) / oldScale,
          };

          // how to scale? Zoom in? Or zoom out?
          let direction = e.evt.deltaY > 0 ? -1 : 1;

          // when we zoom on trackpad, e.evt.ctrlKey is true
          // in that case lets revert direction
          if (e.evt.ctrlKey) {
            direction = -direction;
          }

          var newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

          stage.scale({ x: newScale, y: newScale });

          var newPos = {
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale,
          };
          stage.position(newPos);
        });
      },
      setupSelection() {
        const stage = this.getStage();
        const layer = this.$refs.layer.getNode();

        const tr = new Konva.Transformer({
          rotateEnabled: false,
          resizeEnabled: false,
          flipEnabled: false,
        });
        tr.nodes([]);
        layer.add(tr);

        // add a new feature, lets add ability to draw selection rectangle
        const selectionRectangle = new Konva.Rect({
          fill: 'rgba(0, 0, 255, 0.5)',
          visible: false,
        });
        layer.add(selectionRectangle);

        let x1, y1, x2, y2;
        stage.on('mousedown touchstart', (e) => {
          // do nothing if we mousedown on any shape
          if (e.target !== stage) {
            return;
          }
          e.evt.preventDefault();
          x1 = stage.getPointerPosition().x;
          y1 = stage.getPointerPosition().y;
          x2 = stage.getPointerPosition().x;
          y2 = stage.getPointerPosition().y;

          selectionRectangle.visible(true);
          selectionRectangle.width(0);
          selectionRectangle.height(0);
        });

        stage.on('mousemove touchmove', (e) => {
          // do nothing if we didn't start selection
          if (!selectionRectangle.visible()) {
            return;
          }
          e.evt.preventDefault();
          x2 = stage.getPointerPosition().x;
          y2 = stage.getPointerPosition().y;

          selectionRectangle.setAttrs({
            x: Math.min(x1, x2),
            y: Math.min(y1, y2),
            width: Math.abs(x2 - x1),
            height: Math.abs(y2 - y1),
          });
        });

        stage.on('mouseup touchend', (e) => {
          // do nothing if we didn't start selection
          if (!selectionRectangle.visible()) {
            return;
          }
          e.evt.preventDefault();
          // update visibility in timeout, so we can check it in click event
          setTimeout(() => {
            selectionRectangle.visible(false);
          });

          const shapes = stage.find('.rect');
          const box = selectionRectangle.getClientRect();
          const selected = shapes.filter((shape) =>
            Konva.Util.haveIntersection(box, shape.getClientRect())
          );
          tr.nodes(selected);
        });

        // clicks should select/deselect shapes
        stage.on('click tap', function (e) {
          // if we are selecting with rect, do nothing
          if (selectionRectangle.visible()) {
            return;
          }

          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          // Allow only specific elements as targets and get their
          // parent group as the actual thing we toggle the selection
          // on.
          let group = null;
          if (e.target.hasName('person-image') || e.target.hasName('person-name')) {
            group = e.target.getParent().getParent();
          }
          if (!group) {
            return;
          }

          // do we pressed shift or ctrl?
          const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;
          const isSelected = tr.nodes().indexOf(group) >= 0;

          if (!metaPressed && !isSelected) {
            // if no key pressed and the node is not selected
            // select just one
            tr.nodes([group]);
          } else if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            const nodes = tr.nodes().slice(); // use slice to have new copy of array
            // remove node from array
            nodes.splice(nodes.indexOf(group), 1);
            tr.nodes(nodes);
          } else if (metaPressed && !isSelected) {
            // add the node into selection
            const nodes = tr.nodes().concat([group]);
            tr.nodes(nodes);
          }
        });
      },
    }
  });
  app.use(VueKonva);
  app.mount('#app');
</script>

<style>
  #app {
    width: 100vw;
    height: 100vh;
  }
</style>
